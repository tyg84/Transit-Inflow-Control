# -*- coding: utf-8 -*-
"""New project 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NfWppRxY7n4AGouOxgwcT59RUKL1iqpJ
"""


import folium
import pandas as pd

station_data = pd.read_csv("data/testSubwayStation.csv")

colours = ['red','lightgreen','yellow','lightblue']
coordinates = [[],[],[],[]]
station_names=[[],[],[],[]]
for i in range(len(station_data)):
    coordinates[station_data['Line'][i]-1].append((station_data['Long'][i],station_data['Lat'][i]))
    station_names[station_data['Line'][i]-1].append(station_data['Station name'][i])


m = folium.Map(location=coordinates[0][0], zoom_start=5)
for i in range(len(coordinates)):
    for j, (lat, lon) in enumerate(coordinates[i]):
        folium.Marker(location=(lat, lon), popup=station_names[i][j]).add_to(m)
    folium.PolyLine(locations=coordinates[i], color=colours[i], weight=5, opacity=0.7).add_to(m)


"""new code for adjlist and dijkstra"""

from collections import defaultdict

adjlist = defaultdict(list)

for i in range(len(station_data) - 1):
    if station_data['Line'][i] == station_data['Line'][i + 1]:
        u = int(station_data['station id'][i])
        v = int(station_data['station id'][i + 1])
        w = int(station_data['station time'][i + 1] - station_data['station time'][i])
        line = int(station_data['Line'][i])

        # Add both directions with line info
        adjlist[u].append([v, w, line])
        adjlist[v].append([u, w, line])

import heapq
from collections import defaultdict

import heapq
from collections import defaultdict

def dijkstra_with_path(adjlist, start):
    # dist[(station, line)] = best distance reaching station via line
    dist = defaultdict(lambda: float('inf'))
    parent = {}

    # Start with no line yet (-1)
    dist[(start, -1)] = 0
    pq = [(0, start, -1)]  # (distance, station, line)

    while pq:
        d, u, uline = heapq.heappop(pq)
        if d > dist[(u, uline)]:
            continue

        for v, w, vline in adjlist[u]:  # <-- now unpacks 3 values
            penalty = 0 if uline in (-1, vline) else 3  # 3 min penalty when switching
            newd = d + w + penalty

            if newd < dist[(v, vline)]:
                dist[(v, vline)] = newd
                parent[(v, vline)] = (u, uline)
                heapq.heappush(pq, (newd, v, vline))

    return dist, parent


def reconstruct_path(parent, start, target, dist):
    # pick the best line for the target
    candidate_lines = [line for (station, line) in dist if station == target]
    if not candidate_lines:
        return []

    best_line = min(candidate_lines, key=lambda l: dist[(target, l)])
    if dist[(target, best_line)] == float('inf'):
        return []

    # trace back
    path = []
    curr = (target, best_line)
    while curr in parent or curr[0] == start:
        station, line = curr
        path.append((station, line))
        if station == start:
            break
        curr = parent.get(curr)
        if curr is None:
            break

    path.reverse()

    # flatten into [station, line, station, line, ..., station]
    flat = []
    for i, (station, line) in enumerate(path):
        flat.append(station)
        if i < len(path) - 1:
            flat.append(path[i + 1][1])
    return flat


mindist = defaultdict(dict)
minpath = defaultdict(dict)

for sid in adjlist:
    dist, parent = dijkstra_with_path(adjlist, sid)
    targets = set(station for (station, line) in dist.keys())
    for target in targets:
        bestd, bestline = min(
            ((dist[(target, l)], l) for l in {line for (s, line) in dist if s == target}),
            key=lambda x: x[0]
        )
        if bestd < float('inf'):
            mindist[sid][target] = bestd
            minpath[sid][target] = reconstruct_path(parent, sid, target, dist)



"""old station management code"""

stationpopcoeff=2
import math
import numpy as np
def curve(x):
    return (x-330)**2*(1-((x-330)/240))/2400*stationpopcoeff
weights = station_data["workrating"].values.astype(float)
weights = weights / weights.sum()

line_freq = [2.5,2.5]
line_cap = [2480,2480]

"""

#code to generate trains

station_ids = [[],[]]

for i in range(len(station_data)):
    station_ids[station_data['Line'][i]-1].append(station_data['station id'][i])

trains = { #departure time, current station index (starts at 0), current station id, line, direction, current people in train
}
#last train at 600
#line variable starts at 0
for line in range(len(coordinates)):
    time = 330
    trainnum = 1
    while time<600:
        trains[1000*(line+1)+trainnum] = [int(time), 0, station_ids[line][0], line, 1,0]
        trains[1000*(line+2)-trainnum] = [int(time), len(station_ids[line])-1, station_ids[line][-1], line, -1,0]
        time=time+line_freq[line]
        trainnum+=1
print("train id 1900: "+str(trains[1900]))

"""

station_data["volume"] = [[0] * len(station_data) for asd in range(len(station_data))]
for time in range(330,800): #stop sending new passengers at 630
    #add new commuters
    for i in range(len(station_data)):
        x = curve(time)
        dest_samples = np.random.choice(len(station_data), size=max(0,int(x)*station_data["poprating"][i]), p=weights)
        counts = np.bincount(dest_samples, minlength=len(station_data))
        for j in range(len(station_data)):
            station_data["volume"][i][j] += counts[j]

    #render trains



    #load trains


    #remove destination commuters
print(station_data["volume"])
print(sum(station_data["volume"][0]))

"""Test block"""

station_lines = station_data.groupby("station id")["Line"].apply(list).to_dict()
print(station_lines)

# neighbors[(station_id, line)] = [neighbor_station_A, neighbor_station_B]
neighbors = {}

"""New station management code"""

import math
import numpy as np
from collections import deque

stationpopcoeff = 20
line_freq = [2.5, 2.5, 5, 1.8]
line_cap = [2480, 2480, 1860,1860]

station_arrivals = {int(sid): 0 for sid in station_data["station id"]}
station_transfers = {int(sid): 0 for sid in station_data["station id"]}

def curve(x):
    return (x - 330) ** 2 * (1 - ((x - 330) / 240)) / 2400 * stationpopcoeff

def mult(t, x, tol=1e-8):
    if x <= 0:
        raise ValueError("x must be positive")
    n = round(t / x)
    return abs(t - n * x) < tol

weights = station_data["workrating"].values.astype(float)
weights = weights / weights.sum()

queue = {
    int(station_id): {
        int(line): {0: deque(), 1: deque()}
        for line in station_lines[station_id]
    }
    for station_id in station_lines.keys()
}

station_data["volume"] = [[0] * len(station_data) for _ in range(len(station_data))]


station_index_on_line = {}
for line in set(station_data["Line"]):
    line_stations = station_data[station_data["Line"] == line]["station id"].tolist()
    for idx, sid in enumerate(line_stations):
        station_index_on_line.setdefault(sid, {})[line] = idx


def get_direction(station_a, station_b, line):
    """Return 0 if station_b is lower index on line, 1 if higher."""
    return 0 if station_index_on_line[station_b][line] < station_index_on_line[station_a][line] else 1

#SIM
for time in range(330, 800):

    #SPAWN PASSNEGER
    for i in range(len(station_data)):
        origin_station_id = int(station_data["station id"].iloc[i])

        x = curve(time)
        num_passengers = max(0, int(x) * int(station_data["poprating"].iloc[i]))
        if num_passengers == 0:
            continue

        dest_samples = np.random.choice(len(station_data), size=num_passengers, p=weights)
        counts = np.bincount(dest_samples, minlength=len(station_data))

        for j, count in enumerate(counts):
            if count == 0:
                continue

            dest_station_id = int(station_data["station id"].iloc[j])
            if dest_station_id == origin_station_id or mindist[origin_station_id][dest_station_id] <= 0:
                continue

            station_data["volume"][i][j] += count
            path = minpath[origin_station_id][dest_station_id]
            if not path or len(path) < 3:
                continue

            first_line_number = int(path[1])
            next_station_id = int(path[2])

            direction = get_direction(origin_station_id, next_station_id, first_line_number)
            for _ in range(count):
                queue[origin_station_id][first_line_number][direction].append(dest_station_id)

    #MOVE PASSENGEr
    for i in range(len(station_data)):
        station_id = int(station_data["station id"].iloc[i])
        line_num = int(station_data["Line"].iloc[i])

        if mult(time, line_freq[line_num - 1]):
            for _ in range(line_cap[line_num - 1]):
                if len(queue[station_id][line_num][0]) == 0 and len(queue[station_id][line_num][1]) == 0:
                    break

                for direction_key in [0, 1]:
                    if not queue[station_id][line_num][direction_key]:
                        continue

                    passenger = int(queue[station_id][line_num][direction_key].popleft())
                    path = minpath[station_id][passenger]
                    next_station = int(path[2])

                    #Case arrival
                    if len(path) <= 3:
                        station_arrivals[next_station] += 1
                        continue

                    next_line = int(path[1])
                    if path[3] == next_line:
                        #case continue same line
                        move_dir = get_direction(station_id, next_station, next_line)
                        queue[next_station][next_line][move_dir].appendleft(passenger)
                    else:
                        #case transfer
                        transfer_line = int(path[3])
                        station_transfers[next_station] += 1
                        next_transfer_station = int(path[4])  #next station after transfer
                        transfer_dir = get_direction(next_station, next_transfer_station, transfer_line)
                        queue[next_station][transfer_line][transfer_dir].append(passenger)
    """
    if time == 511:
        print(len(queue[113][1][0]))
        print(len(queue[113][1][1]))
        print(len(queue[113][2][0]))
        print(len(queue[113][2][1]))"""


print(station_transfers)
print("total commuters handled: "+str(sum(station_arrivals.values())))
print("avg number of transfers per commuters: "+str(sum(station_transfers.values())/sum(station_arrivals.values())))
station_totals = {k: station_transfers.get(k, 0) + station_arrivals.get(k, 0) for k in set(station_transfers) | set(station_arrivals)}
top10 = sorted(station_totals.items(), key=lambda x: x[1], reverse=True)[:10]
for sid, total in top10:
    station_name = station_data.loc[station_data["station id"] == sid, "Station name"].values[0]
    print(f"Station {station_name} (ID {sid}): {total}")

import folium

crowdedness = {}
for i in range(len(station_data)):
    station_id = int(station_data["station id"].iloc[i])
    crowdedness[station_id] = station_arrivals[station_id] + station_transfers[station_id]

values = np.array(list(crowdedness.values()))
min_val, max_val = values.min(), values.max()
normalized_crowdedness = {k: (v - min_val) / (max_val - min_val) for k, v in crowdedness.items()}

import folium
import numpy as np

color_scheme = ['#008000', '#32a852', '#7fcb2d', '#c7e200', '#ffd300', '#ff9e00', '#ff6100', '#e00000', '#a60000', '#660000']


crowdedness = {}
for i in range(len(station_data)):
    station_id = int(station_data["station id"].iloc[i])
    crowdedness[station_id] = station_arrivals[station_id] + station_transfers[station_id]

values = np.array(list(crowdedness.values()))
min_val, max_val = values.min(), values.max()

def get_color(value):
    if max_val == min_val:  # all values are the same
        return color_scheme[len(color_scheme)//2]  # pick a middle color
    normalized = (value - min_val) / (max_val - min_val)
    idx = int(normalized * (len(color_scheme) - 1))
    return color_scheme[idx]


m = folium.Map(location=coordinates[0][0], zoom_start=5)

for i in range(len(coordinates)):
    for j, (lat, lon) in enumerate(coordinates[i]):
        station_id = int(station_data["station id"].iloc[station_data.index[station_data['Station name']==station_names[i][j]][0]])
        crowd = crowdedness[station_id]

        radius = 5

        folium.CircleMarker(
            location=(lat, lon),
            radius=radius,
            color=get_color(crowd),
            fill=True,
            fill_color=get_color(crowd),
            fill_opacity=0.7,
            popup=f"{station_names[i][j]}<br>Crowdedness: {crowd}"
        ).add_to(m)

    # Draw lines
    folium.PolyLine(locations=coordinates[i], color=colours[i], weight=5, opacity=0.7).add_to(m)

m



"""Old Code"""

import math
import numpy as np
from collections import deque, Counter

stationpopcoeff = 10
line_freq = [2.5, 2.5,5]
line_cap = [2480, 2480,1860]

station_arrivals = {int(station_id): 0 for station_id in station_data["station id"]}
station_transfers = {int(station_id): 0 for station_id in station_data["station id"]}

def curve(x):
    return (x-330)**2*(1-((x-330)/240))/2400*stationpopcoeff

def mult(t, x, tol=1e-8):  # check if t is multiple of x
    if x <= 0:
        raise ValueError("x must be positive")
    n = round(t / x)
    return abs(t - n*x) < tol

weights = station_data["workrating"].values.astype(float)
weights = weights / weights.sum()

queue = {
    int(station_id): {
        int(line): {0: deque(), 1: deque()}
        for line in station_lines[station_id]
    }
    for station_id in station_lines.keys()
}
"""
queue = [[[deque() for direction in range(2)]  # only 0 or 1
          for line in range(len(coordinates))]
          for station in range(len(station_data))]
"""

station_data["volume"] = [[0] * len(station_data) for _ in range(len(station_data))]

#SIM
for time in range(330, 800):
    #SPAWN PASSENGERS
    for i in range(len(station_data)):
        origin_station_id = int(station_data["station id"].iloc[i])

        x = curve(time)
        num_passengers = max(0, int(x) * int(station_data["poprating"].iloc[i]))
        if num_passengers == 0:
            continue

        dest_samples = np.random.choice(len(station_data), size=num_passengers, p=weights)
        counts = np.bincount(dest_samples, minlength=len(station_data))

        for j in range(len(station_data)):
            if counts[j] == 0:
                continue

            dest_station_id = int(station_data["station id"].iloc[j])

            #skip same-origin destinations
            if dest_station_id == origin_station_id or mindist[origin_station_id][dest_station_id] <= 0:
                continue

            station_data["volume"][i][j] += counts[j]

            path = minpath[origin_station_id][dest_station_id]
            if not path or len(path) < 3:
                continue

            first_line_number = int(path[1])
            next_station_id = int(path[2])

            origin_idx = i
            next_idx = station_data.index[station_data["station id"] == next_station_id][0]

            #dir 0 = lower index on data, dir 1= higher index
            direction = 0 if next_idx < origin_idx else 1

            for _ in range(counts[j]):
                queue[origin_station_id][first_line_number][direction].append(dest_station_id)

    #MOVE PASSENGERS TOWARD STATION
    for i in range(len(station_data)):
        station_id = int(station_data["station id"][i])
        line_num = int(station_data["Line"][i])

        if mult(time, line_freq[line_num-1]):
            for j in range(line_cap[line_num-1]):
                if(len(queue[station_id][line_num][0])==0 and len(queue[station_id][line_num][1])==0):
                    break
                if(len(queue[station_id][line_num][0])>0):
                    nextpassengerup = int(queue[station_id][line_num][0].popleft())

                    #next station
                    nextstationup = int(minpath[station_id][nextpassengerup][2])

                    #case arrival
                    if len(minpath[station_id][nextpassengerup]) <= 3:
                        station_arrivals[nextstationup] = station_arrivals[nextstationup] + 1

                    #case continue on line
                    elif minpath[station_id][nextpassengerup][3] == minpath[station_id][nextpassengerup][1]:
                        queue[nextstationup][line_num][0].appendleft(nextpassengerup)

                    #case transfers
                    elif minpath[station_id][nextpassengerup][3] != minpath[station_id][nextpassengerup][1]:
                        transfer_line_up = int(minpath[station_id][nextpassengerup][3])
                        station_transfers[nextstationup] = station_transfers[nextstationup] + 1
                        queue[nextstationup][transfer_line_up][1].append(nextpassengerup)
                if(len(queue[station_id][line_num][1])>0):


                    #same for other direction
                    nextpassengerdown = int(queue[station_id][line_num][1].popleft())
                    nextstationdown = int(minpath[station_id][nextpassengerdown][2])
                    if len(minpath[station_id][nextpassengerdown]) <= 3:
                        station_arrivals[nextstationdown] = station_arrivals[nextstationdown] + 1
                    elif minpath[station_id][nextpassengerdown][3] == minpath[station_id][nextpassengerdown][1]:
                        queue[nextstationdown][line_num][1].appendleft(nextpassengerdown)
                    elif minpath[station_id][nextpassengerdown][3] != minpath[station_id][nextpassengerdown][1]:
                        transfer_line_down = int(minpath[station_id][nextpassengerdown][3])
                        station_transfers[nextstationdown] = station_transfers[nextstationdown] + 1
                        queue[nextstationdown][transfer_line_down][0].append(nextpassengerdown)

    if time==511:
        print(len(queue[113][1][0]))
        print(len(queue[113][1][1]))
        print(len(queue[113][2][0]))
        print(len(queue[113][2][1]))

#RESULTS
"""
for i in range(len(station_data)):
    print(f"Station {station_data['station id'][i]}: {station_data['volume'][i]}")
"""
"""
print("\nFull queue contents:")
for station_id, line_dict in queue.items():
    print(f"Station {station_id}:")
    for line_number, dirs in line_dict.items():
        for direction, q in dirs.items():
            print(f"  Line {line_number} dir {direction} queue: {list(q)}")"""

#print(queue[101][1][1])

print(station_arrivals)
print(station_transfers)

import math
import numpy as np
from collections import deque, Counter

stationpopcoeff = 10
line_freq = [2.5, 2.5,5]
line_cap = [2480, 2480,1860]

station_arrivals = {int(station_id): 0 for station_id in station_data["station id"]}
station_transfers = {int(station_id): 0 for station_id in station_data["station id"]}

def curve(x):
    return (x-330)**2*(1-((x-330)/240))/2400*stationpopcoeff

def mult(t, x, tol=1e-8):  # check if t is multiple of x
    if x <= 0:
        raise ValueError("x must be positive")
    n = round(t / x)
    return abs(t - n*x) < tol

weights = station_data["workrating"].values.astype(float)
weights = weights / weights.sum()

queue = {
    int(station_id): {
        int(line): {0: deque(), 1: deque()}
        for line in station_lines[station_id]
    }
    for station_id in station_lines.keys()
}
"""
queue = [[[deque() for direction in range(2)]  # only 0 or 1
          for line in range(len(coordinates))]
          for station in range(len(station_data))]
"""

station_data["volume"] = [[0] * len(station_data) for _ in range(len(station_data))]

#SIM
for time in range(330, 800):
    #print(time)
    #SPAWN PASSENGERS
    for i in range(len(station_data)):
        origin_station_id = int(station_data["station id"].iloc[i])

        x = curve(time)
        num_passengers = max(0, int(x) * int(station_data["poprating"].iloc[i]))
        if num_passengers == 0:
            continue

        dest_samples = np.random.choice(len(station_data), size=num_passengers, p=weights)
        counts = np.bincount(dest_samples, minlength=len(station_data))

        for j in range(len(station_data)):
            if counts[j] == 0:
                continue

            dest_station_id = int(station_data["station id"].iloc[j])

            #skip same-origin destinations
            if dest_station_id == origin_station_id or mindist[origin_station_id][dest_station_id] <= 0:
                continue

            station_data["volume"][i][j] += counts[j]

            path = minpath[origin_station_id][dest_station_id]
            if not path or len(path) < 3:
                continue

            first_line_number = int(path[1])
            next_station_id = int(path[2])

            origin_idx = i
            next_idx = station_data.index[station_data["station id"] == next_station_id][0]

            #dir 0 = lower index on data, dir 1= higher index
            direction = 0 if next_idx < origin_idx else 1

            for _ in range(counts[j]):
                queue[origin_station_id][first_line_number][direction].append(dest_station_id)

    #MOVE PASSENGERS TOWARD STATION
    for i in range(len(station_data)):
        station_id = int(station_data["station id"][i])
        line_num = int(station_data["Line"][i])

        if mult(time, line_freq[line_num-1]):
            for j in range(line_cap[line_num-1]):
                # Stop if no passengers in either direction
                if len(queue[station_id][line_num][0]) == 0 and len(queue[station_id][line_num][1]) == 0:
                    break

                for direction_key in [0, 1]:
                    while len(queue[station_id][line_num][direction_key]) > 0:
                        passenger = int(queue[station_id][line_num][direction_key].popleft())
                        next_station = int(minpath[station_id][passenger][2])

                        # Case: arrival
                        if len(minpath[station_id][passenger]) <= 3:
                            station_arrivals[next_station] += 1
                            continue

                        # Determine the next line the passenger will take
                        next_line = int(minpath[station_id][passenger][1])

                        # Compute direction along this line
                        line_stations = station_data.index[station_data['Line'] == next_line].tolist()
                        current_idx = line_stations.index(
                            station_data.index[(station_data['Line'] == next_line) & (station_data['station id'] == station_id)][0]
                        )
                        next_idx = line_stations.index(
                            station_data.index[(station_data['Line'] == next_line) & (station_data['station id'] == next_station)][0]
                        )
                        move_direction = 0 if next_idx < current_idx else 1

                        # Case: continue on the same line
                        if minpath[station_id][passenger][3] == next_line:
                            queue[next_station][next_line][move_direction].appendleft(passenger)

                        # Case: transfer to another line
                        else:
                            transfer_line = int(minpath[station_id][passenger][3])
                            station_transfers[next_station] += 1

                            # Determine direction along transfer line
                            transfer_line_stations = station_data.index[station_data['Line'] == transfer_line].tolist()
                            current_idx_transfer = transfer_line_stations.index(
                                station_data.index[
                                    (station_data['Line'] == transfer_line) & (station_data['station id'] == next_station)
                                ][0]
                            )
                            # Next station on the transfer line in path
                            next_transfer_station = int(minpath[station_id][passenger][4])  # adjust index if needed
                            next_idx_transfer = transfer_line_stations.index(
                                station_data.index[
                                    (station_data['Line'] == transfer_line) & (station_data['station id'] == next_transfer_station)
                                ][0]
                            )
                            transfer_direction = 0 if next_idx_transfer < current_idx_transfer else 1

                            queue[next_station][transfer_line][transfer_direction].append(passenger)


    if time==511:
        print(len(queue[113][1][0]))
        print(len(queue[113][1][1]))
        print(len(queue[113][2][0]))
        print(len(queue[113][2][1]))

#RESULTS
"""
for i in range(len(station_data)):
    print(f"Station {station_data['station id'][i]}: {station_data['volume'][i]}")
"""
"""
print("\nFull queue contents:")
for station_id, line_dict in queue.items():
    print(f"Station {station_id}:")
    for line_number, dirs in line_dict.items():
        for direction, q in dirs.items():
            print(f"  Line {line_number} dir {direction} queue: {list(q)}")"""

#print(queue[101][1][1])

print(station_arrivals)
print(station_transfers)